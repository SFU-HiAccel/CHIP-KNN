#!/usr/bin/python 

import os
import re
import math 
import sys
import stat
from config import *

"""
Each function in this script is meant to generate some of the supporting code for CHIP-KNN.
For example, the makefile and the host CPP code.
"""

def Generate_Host_Code(_num_PE, _knn_config):
    host_file_name = 'knn-host.cpp'
    _host__file = []

    _host__file.append('#include <chrono>' + "\n")
    _host__file.append('#include <iostream>' + "\n")
    _host__file.append('#include <vector>' + "\n")
    _host__file.append('#include <algorithm>' + "\n")
    _host__file.append('#include <stdint.h>' + "\n")
    _host__file.append('#include <stdlib.h>' + "\n")
    _host__file.append('#include <string.h>' + "\n")
    _host__file.append('#include <ctime>' + "\n")
    _host__file.append('#include <math.h>' + "\n")
    _host__file.append('#include <unordered_set>' + "\n")
    _host__file.append('' + "\n")
    _host__file.append('#include <gflags/gflags.h>' + "\n")
    _host__file.append('#include <tapa.h>' + "\n")
    _host__file.append('' + "\n")
    _host__file.append('#include "knn.h"' + "\n")
    _host__file.append('' + "\n")
    _host__file.append('using std::clog;' + "\n")
    _host__file.append('using std::endl;' + "\n")
    _host__file.append('using std::vector;' + "\n")
    _host__file.append('using std::chrono::duration;' + "\n")
    _host__file.append('using std::chrono::high_resolution_clock;' + "\n")
    _host__file.append('' + "\n")

    _host__file.append('void Knn(' + "\n")
    for PE_idx in range(_num_PE):
        _host__file.append('    tapa::mmap<INTERFACE_WIDTH> in_' + str(PE_idx) + ',' + "\n")
    _host__file.append('    tapa::mmap<INT32> final_out' + "\n")
    _host__file.append('    );' + "\n")
    _host__file.append('' + "\n")

    _host__file.append('DEFINE_string(bitstream, "", "path to bitstream file, run csim if empty");' + "\n")
    _host__file.append('' + "\n")
    _host__file.append('struct {' + "\n")
    _host__file.append('    bool operator()(const std::pair<DATA_TYPE, int>& a, const std::pair<DATA_TYPE, int>& b){' + "\n")
    _host__file.append('        if (a.first < b.first) {' + "\n")
    _host__file.append('            return true;' + "\n")
    _host__file.append('        } else if (a.first > b.first) {' + "\n")
    _host__file.append('            return false;' + "\n")
    _host__file.append('        } else {' + "\n")
    _host__file.append('            // Sort based on ID secondarily.' + "\n")
    _host__file.append('            if (a.second < b.second) {' + "\n")
    _host__file.append('                return true;' + "\n")
    _host__file.append('            } else {' + "\n")
    _host__file.append('                return false;' + "\n")
    _host__file.append('            }' + "\n")
    _host__file.append('        }' + "\n")
    _host__file.append('    }' + "\n")
    _host__file.append('} custom_cmp;' + "\n")
    _host__file.append('' + "\n")

    ###################################

    _host__file.append('' + "\n")
    _host__file.append('DATA_TYPE square_and_handle_overflow(DATA_TYPE input)' + "\n")
    _host__file.append('{' + "\n")
    _host__file.append('    // Detect if we will have (over/under)flow after squaring input.' + "\n")
    _host__file.append('    // Return MAX_DATA_TYPE_VAL if we will over or underflow,' + "\n")
    _host__file.append('    //  and input * input if we wont.' + "\n")
    _host__file.append('' + "\n")
    _host__file.append('    if (input == 0) {' + "\n")
    _host__file.append('        return 0;' + "\n")
    _host__file.append('    }' + "\n")
    _host__file.append('    else if (input < -1*MAX_DATA_TYPE_VAL) {' + "\n")
    _host__file.append('        // if input is the smallest possible value, the rest of the handling wont work properly.' + "\n")
    _host__file.append('        return MAX_DATA_TYPE_VAL;' + "\n")
    _host__file.append('    }' + "\n")

    if (_knn_config.using_float):
        _host__file.append('    else if ( (fabs(input) >= FLOOR_SQRT_MAX_DATA_TYPE_VAL) ) {' + "\n")
        _host__file.append('        return MAX_DATA_TYPE_VAL;' + "\n")
        _host__file.append('    }' + "\n")
    elif (_knn_config.using_fixedpt):
        _host__file.append('    else if ( (fabs(input.to_float()) >= FLOOR_SQRT_MAX_DATA_TYPE_VAL) ) {' + "\n")
        _host__file.append('        return MAX_DATA_TYPE_VAL;' + "\n")
        _host__file.append('    }' + "\n")

    _host__file.append('    else {' + "\n")
    _host__file.append('        return input * input;' + "\n")
    _host__file.append('    }' + "\n")
    _host__file.append('' + "\n")
    _host__file.append('}' + "\n")
    _host__file.append('' + "\n")

    ###################################

    _host__file.append('DATA_TYPE add_and_handle_overflow(DATA_TYPE a_val, DATA_TYPE b_val)' + "\n")
    _host__file.append('{' + "\n")
    _host__file.append('    // Detect if we will have (over/under)flow after addition.' + "\n")
    _host__file.append('    // Return MAX_DATA_TYPE_VAL if we will overflow, -1*MAX_DATA_TYPE_VAL if we will underflow,' + "\n")
    _host__file.append('    //  and a_val + b_val if we wont.' + "\n")
    _host__file.append('' + "\n")
    _host__file.append('    if ((a_val > 0) && (b_val > static_cast<DATA_TYPE>(MAX_DATA_TYPE_VAL) - a_val)) {' + "\n")
    _host__file.append('        return MAX_DATA_TYPE_VAL;' + "\n")
    _host__file.append('    }' + "\n")
    _host__file.append('    else if ((a_val < 0) && (b_val < static_cast<DATA_TYPE>(-1*MAX_DATA_TYPE_VAL) - a_val)) {' + "\n")
    _host__file.append('        // NOTE: dont return MIN, because fabs() behaves incorrectly with MIN.' + "\n")
    _host__file.append('        return -1 * MAX_DATA_TYPE_VAL;' + "\n")
    _host__file.append('    }' + "\n")
    _host__file.append('    else {' + "\n")
    _host__file.append('        return a_val + b_val;' + "\n")
    _host__file.append('    }' + "\n")
    _host__file.append('}' + "\n")
    _host__file.append('' + "\n")
    _host__file.append('' + "\n")

    ###################################

    _host__file.append('DATA_TYPE calc_single_dim_dist( DATA_TYPE query_point,' + "\n")
    _host__file.append('                                DATA_TYPE data_point)' + "\n")
    _host__file.append('{' + "\n")
    _host__file.append('    DATA_TYPE delta=0.0;' + "\n")
    _host__file.append('' + "\n")
    _host__file.append('    if (DISTANCE_METRIC == 0){' + "\n")

    if (_knn_config.using_float):
        _host__file.append('        delta = fabs( add_and_handle_overflow(query_point,  -1*data_point) );' + "\n")
    elif (_knn_config.using_fixedpt):
        _host__file.append('        delta = fabs( add_and_handle_overflow(query_point,  -1*data_point).to_float() );' + "\n")

    _host__file.append('    }else if (DISTANCE_METRIC == 1){' + "\n")
    _host__file.append('        delta = add_and_handle_overflow(query_point,  -1*data_point);' + "\n")
    _host__file.append('        delta = square_and_handle_overflow(delta);' + "\n")
    _host__file.append('    }' + "\n")
    _host__file.append('    return delta;' + "\n")
    _host__file.append('}' + "\n")
    _host__file.append('' + "\n")

    ###################################

    _host__file.append('bool elementsAreDistinct(std::vector<int, tapa::aligned_allocator<int>> input)' + "\n")
    _host__file.append('{' + "\n")
    _host__file.append('    int input_size = input.size();' + "\n")
    _host__file.append('' + "\n")
    _host__file.append('    std::unordered_set<int> element_set;' + "\n")
    _host__file.append('    for (int i = 0; i < input_size; ++i) {' + "\n")
    _host__file.append('        element_set.insert(input[i]);' + "\n")
    _host__file.append('    }' + "\n")
    _host__file.append('' + "\n")
    _host__file.append('    return (element_set.size() == input.size());' + "\n")
    _host__file.append('}' + "\n")

    ###################################

    _host__file.append('// Function for verifying results' + "\n")
    _host__file.append('bool verify(std::vector<DATA_TYPE, tapa::aligned_allocator<DATA_TYPE>> &sw_dist,' + "\n")

    if (_knn_config.data_type_total_sz < 32):
        _host__file.append('            std::vector<INT32, tapa::aligned_allocator<INT32>> &hw_dist_raw,' + "\n")

    _host__file.append('            std::vector<DATA_TYPE, tapa::aligned_allocator<DATA_TYPE>> &hw_dist,' + "\n")
    _host__file.append('            std::vector<int, tapa::aligned_allocator<int>> &sw_id,' + "\n")
    _host__file.append('            std::vector<int, tapa::aligned_allocator<int>> &hw_id,' + "\n")
    _host__file.append('            std::vector<DATA_TYPE, tapa::aligned_allocator<DATA_TYPE>> &query,' + "\n")
    _host__file.append('            std::vector<DATA_TYPE, tapa::aligned_allocator<DATA_TYPE>> &searchSpace,' + "\n")
    _host__file.append('            unsigned int size)' + "\n")
    _host__file.append('{' + "\n")
    _host__file.append('    bool check = true;' + "\n")
    _host__file.append('' + "\n")
    _host__file.append('    if (elementsAreDistinct(hw_id) == false)' + "\n")
    _host__file.append('    {' + "\n")
    _host__file.append('        check = false;' + "\n")
    _host__file.append('        std::cout << "ERROR!!! Some of the FPGAs IDs are duplicates!" << std::endl;' + "\n")
    _host__file.append('    }' + "\n")
    _host__file.append('    if (elementsAreDistinct(sw_id) == false)' + "\n")
    _host__file.append('    {' + "\n")
    _host__file.append('        check = false;' + "\n")
    _host__file.append('        std::cout << "TEST GENERATION ERROR. Some of the CPUs Top K IDs are duplicates." << std::endl;' + "\n")
    _host__file.append('    }' + "\n")
    _host__file.append('' + "\n")

    if (_knn_config.data_type_total_sz < 32):
        _host__file.append('    // Workaround for a problem with non-32-bit-aligned data widths.' + "\n")
        _host__file.append('    for (int i = 0; i < size; ++i)' + "\n")
        _host__file.append('    {' + "\n")
        _host__file.append('        hw_dist[i].range(DATA_TYPE_TOTAL_SZ-1, 0) = hw_dist_raw[i].range(DATA_TYPE_TOTAL_SZ-1, 0);' + "\n")
        _host__file.append('    }' + "\n")

    _host__file.append('' + "\n")
    _host__file.append('    for (unsigned int i=0; i<size; ++i) {' + "\n")
    _host__file.append('' + "\n")
    _host__file.append('        std::cout << "i = " << i' + "\n")
    _host__file.append('                  << std::endl;' + "\n")
    _host__file.append('' + "\n")
    _host__file.append('        // The top K distances all must match, otherwise there was a bug.' + "\n")
    _host__file.append('        if (sw_dist[i] != hw_dist[i]) {' + "\n")
    _host__file.append('            check = false;' + "\n")
    _host__file.append('            std::cout << "    ERROR!!! Result mismatch on i = " << i' + "\n")
    _host__file.append('                      << std::endl;' + "\n")
    _host__file.append('        }' + "\n")
    _host__file.append('        // If the ID doesnt match, there might have been a few points that' + "\n")
    _host__file.append('        // coincidentally had the same distance, and the FPGA might have returned' + "\n")
    _host__file.append('        // them in a different order. Check to make sure these distances' + "\n")
    _host__file.append('        // are correct.' + "\n")
    _host__file.append('        else if (sw_id[i] != hw_id[i]) {' + "\n")
    _host__file.append('            DATA_TYPE tmp_sw_dist;' + "\n")
    _host__file.append('            DATA_TYPE tmp_hw_dist;' + "\n")
    _host__file.append('            DATA_TYPE delta_sum = 0;' + "\n")
    _host__file.append('            DATA_TYPE delta = 0;' + "\n")
    _host__file.append('' + "\n")
    _host__file.append('            // Calculate distance for the sw_id, and the hw_id.' + "\n")
    _host__file.append('            delta_sum = 0.0;' + "\n")
    _host__file.append('            for (unsigned int j=0; j<INPUT_DIM; ++j){' + "\n")
    _host__file.append('                delta = calc_single_dim_dist(query[j], searchSpace[sw_id[i]*INPUT_DIM+j]);' + "\n")
    _host__file.append('                delta_sum = add_and_handle_overflow( delta_sum, delta );' + "\n")
    _host__file.append('            }' + "\n")
    _host__file.append('            tmp_sw_dist = delta_sum;' + "\n")
    _host__file.append('' + "\n")
    _host__file.append('            delta_sum = 0.0;' + "\n")
    _host__file.append('            for (unsigned int j=0; j<INPUT_DIM; ++j){' + "\n")
    _host__file.append('                delta = calc_single_dim_dist(query[j], searchSpace[hw_id[i]*INPUT_DIM+j]);' + "\n")
    _host__file.append('                delta_sum = add_and_handle_overflow( delta_sum, delta );' + "\n")
    _host__file.append('            }' + "\n")
    _host__file.append('            tmp_hw_dist = delta_sum;' + "\n")
    _host__file.append('' + "\n")
    _host__file.append('            if (tmp_hw_dist != tmp_sw_dist) {' + "\n")
    _host__file.append('                check = false;' + "\n")
    _host__file.append('                std::cout << "    ERROR!!! Result mismatch on i = " << i' + "\n")
    _host__file.append('                          << std::endl;' + "\n")
    _host__file.append('            } else {' + "\n")
    _host__file.append('                std::cout << "    ID mismatch, but the distances were the same." << std::endl;' + "\n")
    _host__file.append('            }' + "\n")
    _host__file.append('        }' + "\n")
    _host__file.append('' + "\n")
    _host__file.append('        std::cout << " CPU result = " << sw_id[i] << " : " << sw_dist[i]' + "\n")
    _host__file.append('                  << std::endl' + "\n")
    _host__file.append('                  << " FPGA result = " << hw_id[i] << " : " << hw_dist[i]' + "\n")
    _host__file.append('                  << std::endl' + "\n")
    
    if (_knn_config.using_float):
        _host__file.append('                  << " Delta = " << fabs(sw_dist[i] - hw_dist[i])' + "\n")
    elif (_knn_config.using_fixedpt):
        _host__file.append('                  << " Delta = " << fabs(sw_dist[i].to_float() - hw_dist[i].to_float())' + "\n")
    _host__file.append('                  << std::endl;' + "\n")
    _host__file.append('' + "\n")
    _host__file.append('    }' + "\n")
    _host__file.append('' + "\n")
    _host__file.append('    return check;' + "\n")
    _host__file.append('}' + "\n")
    _host__file.append('' + "\n")
    _host__file.append('' + "\n")

    ###################################

    _host__file.append('void Generate_sw_verif_data(std::vector<DATA_TYPE, tapa::aligned_allocator<DATA_TYPE>> &query,' + "\n")
    _host__file.append('                            std::vector<DATA_TYPE, tapa::aligned_allocator<DATA_TYPE>> &searchSpace,' + "\n")
    _host__file.append('                            std::vector<DATA_TYPE, tapa::aligned_allocator<DATA_TYPE>> &dist,' + "\n")
    _host__file.append('                            std::vector<int, tapa::aligned_allocator<int>> &id,' + "\n")
    _host__file.append('                            unsigned int num_of_points)' + "\n")
    _host__file.append('{' + "\n")
    _host__file.append('    // Generate random DATA_TYPE data' + "\n")
    _host__file.append('    srand(time(NULL));' + "\n")
    _host__file.append('    std::fill(query.begin(), query.end(), 0.0);' + "\n")
    _host__file.append('    std::fill(searchSpace.begin(), searchSpace.end(), 0.0);' + "\n")
    _host__file.append('    std::fill(dist.begin(), dist.end(), MAX_DATA_TYPE_VAL);' + "\n")
    _host__file.append('    std::fill(id.begin(), id.end(), 0);' + "\n")
    _host__file.append('' + "\n")


    if (_knn_config.using_fixedpt):
        _host__file.append('    float max_generated_val = (FLOOR_SQRT_MAX_DATA_TYPE_VAL > MAX_DATA_TYPE_VAL) ? MAX_DATA_TYPE_VAL : FLOOR_SQRT_MAX_DATA_TYPE_VAL;' + "\n")
        _host__file.append('    max_generated_val = max_generated_val * 2 / INPUT_DIM;' + "\n")
        _host__file.append('' + "\n")

    _host__file.append('    for (unsigned int i=0; i<INPUT_DIM; ++i){' + "\n")
    if (_knn_config.using_float):
        _host__file.append('        // For a float payload, we want to normalize everything between 0 and 1' + "\n")
        _host__file.append('        query[i] = static_cast <DATA_TYPE>(rand()) / static_cast<DATA_TYPE>(RAND_MAX);' + "\n")
        _host__file.append('        printf("Query[%d] = %f\\n", i, query[i]);' + "\n")
    elif (_knn_config.using_fixedpt):
        _host__file.append('        query[i] = max_generated_val/2;' + "\n")
        _host__file.append('        printf("Query[%d] = %f\\n", i, query[i].to_float());' + "\n")
    _host__file.append('    }' + "\n")
    _host__file.append('' + "\n")
    _host__file.append('#if DATA_TYPE_TOTAL_SZ <= 20' + "\n")
    _host__file.append('    unsigned long long int two_pow_data_type_total_sz = pow(static_cast<double> (2),' + "\n")
    _host__file.append('                                                    static_cast<double> (DATA_TYPE_TOTAL_SZ));' + "\n")
    _host__file.append('    unsigned long long int num_of_non_max_values = two_pow_data_type_total_sz / 4;' + "\n")
    _host__file.append('    //unsigned long long int num_of_non_max_values = 500;' + "\n")
    _host__file.append('    unsigned int start_of_non_max_values = rand() % (num_of_points - num_of_non_max_values);' + "\n")
    _host__file.append('    //unsigned int start_of_non_max_values = 15;' + "\n")
    _host__file.append('' + "\n")
    _host__file.append('    printf("\\nStart of non-max values = %d\\n", start_of_non_max_values);' + "\n")
    _host__file.append('    printf("\\nNum of non-max value = %lld\\n", num_of_non_max_values);' + "\n")
    _host__file.append('#endif' + "\n")
    _host__file.append('' + "\n")
    _host__file.append('' + "\n")


    _host__file.append('    for (unsigned long long int i=0; i<num_of_points*INPUT_DIM; ++i){' + "\n")
    if (_knn_config.using_float):
        _host__file.append('        // For a float payload, we want to normalize everything between 0 and 1' + "\n")
        _host__file.append('        searchSpace[i] = static_cast <DATA_TYPE>(rand()) / static_cast<DATA_TYPE>(RAND_MAX);' + "\n")
        _host__file.append('' + "\n")

    elif (_knn_config.using_fixedpt):
        _host__file.append('        #if DATA_TYPE_TOTAL_SZ > 20' + "\n")
        _host__file.append('        // For more bits in the fixed point payload' + "\n")
        _host__file.append('            float cur_val = static_cast<float>(' + "\n")
        _host__file.append('                                static_cast<float>(rand()) / static_cast<float>(RAND_MAX)' + "\n")
        _host__file.append('                             )*static_cast<float>(max_generated_val);' + "\n")
        _host__file.append('            searchSpace[i] = static_cast<DATA_TYPE>(cur_val);' + "\n")
        _host__file.append('' + "\n")
        _host__file.append('        #else' + "\n")
        _host__file.append('        // If we have a small-bitwidth fixed point payload, we need to constrain the inputs ' + "\n")
        _host__file.append('        //   because there will be collisions.' + "\n")
        _host__file.append('        if ( i/INPUT_DIM >= start_of_non_max_values && i/INPUT_DIM < start_of_non_max_values+num_of_non_max_values){' + "\n")
        _host__file.append('' + "\n")
        _host__file.append('            float cur_val = static_cast<float>(' + "\n")
        _host__file.append('                                static_cast<float>(rand()) / static_cast<float>(RAND_MAX)' + "\n")
        _host__file.append('                             )*static_cast<float>(max_generated_val);' + "\n")
        _host__file.append('            searchSpace[i] = static_cast<DATA_TYPE>(cur_val);' + "\n")
        _host__file.append('' + "\n")

        _host__file.append('        } else {' + "\n")
        _host__file.append('            searchSpace[i] = MAX_DATA_TYPE_VAL;' + "\n")
        _host__file.append('        }' + "\n")
        _host__file.append('        #endif' + "\n")

    _host__file.append('    }' + "\n")
    _host__file.append('' + "\n")
    _host__file.append('    DATA_TYPE delta_sum=0.0;' + "\n")
    _host__file.append('    DATA_TYPE delta=0.0;' + "\n")
    _host__file.append('    std::vector<DATA_TYPE, tapa::aligned_allocator<DATA_TYPE>> distance(num_of_points);' + "\n")
    _host__file.append('' + "\n")
    _host__file.append('    for (unsigned int i=0; i<num_of_points; ++i){' + "\n")
    _host__file.append('        delta_sum = 0.0;' + "\n")
    _host__file.append('        for (unsigned int j=0; j<INPUT_DIM; ++j){' + "\n")
    _host__file.append('            delta = calc_single_dim_dist(query[j], searchSpace[i*INPUT_DIM+j]);' + "\n")
    _host__file.append('            delta_sum = add_and_handle_overflow( delta_sum, delta );' + "\n")
    _host__file.append('        }' + "\n")
    _host__file.append('        distance[i] = delta_sum;' + "\n")
    _host__file.append('' + "\n")
    _host__file.append('        //if (i % 1000 == 0)' + "\n")
    _host__file.append('        //{' + "\n")
    if (_knn_config.using_float):
        _host__file.append('            //printf("KDEBUG: distance[%d] = %f\\n", i, distance[i]);' + "\n")
    elif (_knn_config.using_fixedpt):
        _host__file.append('            //printf("KDEBUG: distance[%d] = %f\\n", i, distance[i].to_float());' + "\n")
    _host__file.append('        //}' + "\n")
    _host__file.append('    }' + "\n")
    _host__file.append('' + "\n")
    _host__file.append('    // Sort distances METHOD 1 (original)' + "\n")
    _host__file.append('    std::vector<DATA_TYPE, tapa::aligned_allocator<DATA_TYPE>> distance_cpy(distance);' + "\n")
    _host__file.append('    std::vector<DATA_TYPE, tapa::aligned_allocator<DATA_TYPE>> dist_old_algo(TOP);' + "\n")
    _host__file.append('    std::vector<int, tapa::aligned_allocator<int>> id_old_algo(TOP);' + "\n")
    _host__file.append('    std::sort(distance_cpy.begin(), distance_cpy.end());' + "\n")
    _host__file.append('' + "\n")
    _host__file.append('    for (int i(0); i < TOP; ++i){' + "\n")
    _host__file.append('        dist_old_algo[i] = distance_cpy[TOP-1-i];' + "\n")
    _host__file.append('    }' + "\n")
    _host__file.append('' + "\n")
    _host__file.append('    for (int i(0); i<TOP; ++i){' + "\n")
    _host__file.append('        for (unsigned int j(0); j < num_of_points; ++j){' + "\n")
    _host__file.append('            if (distance[j] == dist_old_algo[i]){' + "\n")
    _host__file.append('                id_old_algo[i] = j;' + "\n")
    _host__file.append('                break;' + "\n")
    _host__file.append('            }' + "\n")
    _host__file.append('        }' + "\n")
    _host__file.append('    }' + "\n")
    _host__file.append('' + "\n")
    _host__file.append('    // Sort distances METHOD 2 (new)' + "\n")
    _host__file.append('    std::vector<std::pair<DATA_TYPE, int>> distance_and_id(num_of_points);' + "\n")
    _host__file.append('' + "\n")
    _host__file.append('    for (unsigned int i(0); i < num_of_points; ++i){' + "\n")
    _host__file.append('        distance_and_id[i] = std::make_pair(distance[i], i);' + "\n")
    _host__file.append('    }' + "\n")
    _host__file.append('' + "\n")
    _host__file.append('    std::sort(distance_and_id.begin(), distance_and_id.end(), custom_cmp);' + "\n")
    _host__file.append('' + "\n")
    _host__file.append('    for (int i(0); i < TOP; ++i){' + "\n")
    _host__file.append('        dist[i] = distance_and_id[TOP-1-i].first;' + "\n")
    _host__file.append('        id[i] = distance_and_id[TOP-1-i].second;' + "\n")
    _host__file.append('    }' + "\n")
    _host__file.append('' + "\n")
    _host__file.append('' + "\n")
    _host__file.append('    // Check to make sure method 2 works' + "\n")
    _host__file.append('    printf("\\n\\nKDEBUG: CHECKING the new sorting method now!!\\n");' + "\n")

    _host__file.append('    for (int i(0); i < TOP; ++i){' + "\n")
    if (_knn_config.using_float):
        _host__file.append('        printf("dist[%d].first      = %f\\n",   i, dist[i]);' + "\n")
        _host__file.append('        printf("dist_old_algo[%d]   = %f\\n",   i, dist_old_algo[i]);' + "\n")
    elif (_knn_config.using_fixedpt):
        _host__file.append('        printf("dist[%d].first      = %f\\n",   i, dist[i].to_float());' + "\n")
        _host__file.append('        printf("dist_old_algo[%d]   = %f\\n",   i, dist_old_algo[i].to_float());' + "\n")
    _host__file.append('        printf("id[%d].second       = %d\\n",   i, id[i]);' + "\n")
    _host__file.append('        printf("id_old_algo[%d]     = %d\\n\\n", i, id_old_algo[i]);' + "\n")
    _host__file.append('' + "\n")
    _host__file.append('        if (dist_old_algo[i] != dist[i]){' + "\n")
    _host__file.append('            printf("\\n\\nERROR IN SOFTWARE SORTING, SOMEHOW :(\\n\\n");' + "\n")
    _host__file.append('            exit(15);' + "\n")
    _host__file.append('        } else if (id_old_algo[i] != id[i]){' + "\n")
    _host__file.append('            printf("\\nWARNING: Top K index %d got a bad ID\\n", i);' + "\n")
    _host__file.append('        }' + "\n")
    _host__file.append('    }' + "\n")
    _host__file.append('' + "\n")
    _host__file.append('    // Debugging: Print a few of the values we generated' + "\n")
    _host__file.append('    for (int i(0); i<TOP; ++i){' + "\n")

    if (_knn_config.using_float):
        _host__file.append('        printf("KDEBUG: dist[%d]        = %f\\n", i, dist[i]);' + "\n")
        _host__file.append('        printf("KDEBUG: searchSpace[%d] = %f\\n", i, searchSpace[i]);' + "\n")
    elif (_knn_config.using_fixedpt):
        _host__file.append('        printf("KDEBUG: dist[%d]        = %f\\n", i, dist[i].to_float());' + "\n")
        _host__file.append('        printf("KDEBUG: searchSpace[%d] = %f\\n", i, searchSpace[i].to_float());' + "\n")

    _host__file.append('    }' + "\n")
    _host__file.append('' + "\n")
    _host__file.append('    return;' + "\n")
    _host__file.append('}' + "\n")
    _host__file.append('' + "\n")

    ###################################

    _host__file.append('int main(int argc, char* argv[]) {' + "\n")
    _host__file.append('    gflags::ParseCommandLineFlags(&argc, &argv, /*remove_flags=*/true);' + "\n")
    _host__file.append('' + "\n")
    _host__file.append('' + "\n")
    _host__file.append('    // DEBUGGING STUFF' + "\n")
    _host__file.append('    printf("KDEBUG: USING_SEGMENTS = %d\\n", USING_SEGMENTS);' + "\n")
    _host__file.append('    printf("KDEBUG: USING_LTYPES = %d\\n", USING_LTYPES);' + "\n")
    _host__file.append('' + "\n")
    _host__file.append('    printf("KDEBUG: INPUT_DIM = %d\\n", INPUT_DIM );' + "\n")
    _host__file.append('    printf("KDEBUG: TOP = %d\\n", TOP);' + "\n")
    _host__file.append('    printf("KDEBUG: NUM_SP_PTS = %d\\n", NUM_SP_PTS);' + "\n")
    _host__file.append('    printf("KDEBUG: DISTANCE_METRIC = %d\\n", DISTANCE_METRIC);' + "\n")
    _host__file.append('    printf("KDEBUG: NUM_PE = %d\\n", NUM_PE);' + "\n")
    _host__file.append('' + "\n")
    _host__file.append('    printf("KDEBUG: NUM_SP_PTS_PER_KRNL_PADDED = %d\\n", NUM_SP_PTS_PER_KRNL_PADDED);' + "\n")
    _host__file.append('    printf("KDEBUG: NUM_BYTES_PER_KRNL_PADDED = %d\\n\\n", NUM_BYTES_PER_KRNL_PADDED);' + "\n")
    _host__file.append('' + "\n")
    _host__file.append('    printf("KDEBUG: size of DATA_TYPE = %ld\\n", sizeof(DATA_TYPE));' + "\n")
    _host__file.append('    printf("KDEBUG: DATA_TYPE_TOTAL_SZ = %d \\n", DATA_TYPE_TOTAL_SZ);' + "\n")
    _host__file.append('    printf("KDEBUG: MAX_DATA_TYPE_VAL = %lf\\n", static_cast<double>(MAX_DATA_TYPE_VAL));' + "\n")
    _host__file.append('    printf("KDEBUG: FLOOR_SQRT_MAX_DATA_TYPE_VAL = %lf\\n\\n", static_cast<double>(FLOOR_SQRT_MAX_DATA_TYPE_VAL));' + "\n")
    _host__file.append('    printf("KDEBUG: IWIDTH = %d \\n\\n", IWIDTH);' + "\n")
    _host__file.append('' + "\n")
    _host__file.append('    printf("KDEBUG: L2I_FACTOR_W= %d\\n", L2I_FACTOR_W);' + "\n")
    _host__file.append('    printf("KDEBUG: D2L_FACTOR_W= %d\\n", D2L_FACTOR_W);' + "\n")
    _host__file.append('    printf("KDEBUG: D2I_FACTOR_W= %d\\n", D2I_FACTOR_W);' + "\n")
    _host__file.append('    printf("KDEBUG: I2D_FACTOR_W= %d\\n", I2D_FACTOR_W);' + "\n")
    _host__file.append('' + "\n")

    if (_knn_config.using_segments == 1): 
        _host__file.append('    printf("KDEBUG: NUM_SEGMENTS = %d \\n", NUM_SEGMENTS);' + "\n")
        _host__file.append('    printf("KDEBUG: SEGMENT_SIZE_IN_D = %d \\n", SEGMENT_SIZE_IN_D);' + "\n")
        _host__file.append('    printf("KDEBUG: SEGMENT_SIZE_IN_L = %d \\n", SEGMENT_SIZE_IN_L);' + "\n")
        _host__file.append('    printf("KDEBUG: SEGMENT_SIZE_IN_I = %d \\n", SEGMENT_SIZE_IN_I);' + "\n")
        _host__file.append('' + "\n")

    _host__file.append('    printf("KDEBUG: PARTITION_LEN_IN_D = %d \\n", PARTITION_LEN_IN_D);' + "\n")
    _host__file.append('    printf("KDEBUG: PARTITION_LEN_IN_L = %d \\n", PARTITION_LEN_IN_L);' + "\n")
    _host__file.append('    printf("KDEBUG: PARTITION_LEN_IN_I = %d \\n", PARTITION_LEN_IN_I);' + "\n")
    _host__file.append('    // END DEBUGGING STUFF' + "\n")
    _host__file.append('' + "\n")
    _host__file.append('' + "\n")
    _host__file.append('    // generate input data' + "\n")
    _host__file.append('    int dataSize = NUM_SP_PTS_PER_KRNL_PADDED * NUM_PE;' + "\n")
    _host__file.append('    vector<DATA_TYPE, tapa::aligned_allocator<DATA_TYPE>> searchspace_data(dataSize*INPUT_DIM);' + "\n")
    _host__file.append('    vector<DATA_TYPE, tapa::aligned_allocator<DATA_TYPE>> searchspace_data_part[NUM_PE];' + "\n")
    _host__file.append('    vector<DATA_TYPE, tapa::aligned_allocator<DATA_TYPE>> query_data(INPUT_DIM);' + "\n")
    _host__file.append('' + "\n")
    _host__file.append('    vector<DATA_TYPE, tapa::aligned_allocator<DATA_TYPE>> sw_dist(TOP);' + "\n")
    _host__file.append('    vector<int, tapa::aligned_allocator<int>> sw_id(TOP);' + "\n")
    _host__file.append('    vector<INT32, tapa::aligned_allocator<INT32>> hw_output(2*TOP);' + "\n")
    _host__file.append('    vector<DATA_TYPE, tapa::aligned_allocator<DATA_TYPE>> hw_dist(TOP);' + "\n")

    if (_knn_config.data_type_total_sz < 32):
        _host__file.append('' + "\n")
        _host__file.append('    // Workaround for a problem with non-32-bit-aligned data widths.' + "\n")
        _host__file.append('    vector<INT32, tapa::aligned_allocator<INT32>> hw_dist_raw(TOP);' + "\n")
        _host__file.append('' + "\n")

    _host__file.append('    vector<int, tapa::aligned_allocator<int>> hw_id(TOP);' + "\n")
    _host__file.append('' + "\n")
    _host__file.append('    // Initializing hw output vectors to zero' + "\n")
    _host__file.append('    std::fill(hw_output.begin(), hw_output.end(), 0);' + "\n")
    _host__file.append('    std::fill(hw_dist.begin(), hw_dist.end(), 0.0);' + "\n")

    if (_knn_config.data_type_total_sz < 32):
        _host__file.append('    std::fill(hw_dist_raw.begin(), hw_dist_raw.end(), 0.0);' + "\n")

    _host__file.append('    std::fill(hw_id.begin(), hw_id.end(), 0);' + "\n")
    _host__file.append('' + "\n")
    _host__file.append('    // generate sw results' + "\n")
    _host__file.append('    auto sw_start_time = high_resolution_clock::now();' + "\n")
    _host__file.append('    Generate_sw_verif_data(query_data, searchspace_data, sw_dist, sw_id, dataSize);' + "\n")
    _host__file.append('    auto sw_stop_time = high_resolution_clock::now();' + "\n")
    _host__file.append('    duration<double> sw_elapsed = sw_stop_time - sw_start_time;' + "\n")
    _host__file.append('    clog << "SOFTWARE time: " << sw_elapsed.count() << " s" << endl;' + "\n")

    _host__file.append('' + "\n")
    _host__file.append('    // partition the full matrix into separate submatrices' + "\n")
    _host__file.append('    int starting_idx = 0;' + "\n")
    _host__file.append('    int part_size = dataSize*INPUT_DIM/NUM_PE;' + "\n")
    _host__file.append('    for (int i = 0; i < NUM_PE; ++i) {' + "\n")
    _host__file.append('        starting_idx = i*part_size;' + "\n")
    _host__file.append('        searchspace_data_part[i].resize(QUERY_FEATURE_RESERVE + part_size);' + "\n")
    _host__file.append('        for (unsigned int j = 0; j < QUERY_FEATURE_RESERVE; ++j){' + "\n")
    _host__file.append('            searchspace_data_part[i][j] = 0.0;' + "\n")
    _host__file.append('        }' + "\n")
    _host__file.append('        for (int j = 0; j < INPUT_DIM; ++j){' + "\n")
    _host__file.append('            searchspace_data_part[i][j] = query_data[j];' + "\n")
    _host__file.append('        }' + "\n")
    _host__file.append('        for (int j = 0; j < part_size; ++j){' + "\n")
    _host__file.append('            searchspace_data_part[i][QUERY_FEATURE_RESERVE + j] = searchspace_data[starting_idx+j];' + "\n")
    _host__file.append('        }' + "\n")
    _host__file.append('    }' + "\n")
    _host__file.append('    // format data based on packing factor on AXI ports' + "\n")

    if (_knn_config.using_float):
        _host__file.append('    vector<INTERFACE_WIDTH> in[NUM_PE];' + "\n")
        _host__file.append('    int data_packing_factor = (IWIDTH/32);' + "\n")
        _host__file.append('    int formatted_length = (QUERY_FEATURE_RESERVE + part_size)/data_packing_factor;' + "\n")
        _host__file.append('    for (int i(0); i<NUM_PE; ++i) {' + "\n")
        _host__file.append('        in[i].resize(formatted_length);' + "\n")
        _host__file.append('        for (int j(0); j<formatted_length; ++j) {' + "\n")
        _host__file.append('            INTERFACE_WIDTH tmp;' + "\n")
        _host__file.append('            for (int k(0); k<data_packing_factor; ++k) {' + "\n")
        _host__file.append('                DATA_TYPE this_ele = searchspace_data_part[i][j*data_packing_factor + k];' + "\n")
        _host__file.append('                tmp.range(k*32+31, k*32) = *((uint32_t *)(&this_ele));' + "\n")
        _host__file.append('            }' + "\n")
        _host__file.append('            in[i][j] = tmp;' + "\n")
        _host__file.append('        }' + "\n")
        _host__file.append('    }' + "\n")

    elif (_knn_config.using_fixedpt):
        _host__file.append('    vector<INTERFACE_WIDTH> in[NUM_PE];' + "\n")
        _host__file.append('    int data_packing_factor = (IWIDTH/DATA_TYPE_TOTAL_SZ);' + "\n")
        _host__file.append('    int formatted_length = (QUERY_FEATURE_RESERVE + part_size)/data_packing_factor;' + "\n")
        _host__file.append('    for (int i(0); i<NUM_PE; ++i) {' + "\n")
        _host__file.append('        in[i].resize(formatted_length);' + "\n")
        _host__file.append('        for (int j(0); j<formatted_length; ++j) {' + "\n")
        _host__file.append('            INTERFACE_WIDTH tmp;' + "\n")
        _host__file.append('            for (int k(0); k<data_packing_factor; ++k) {' + "\n")
        _host__file.append('                DATA_TYPE this_ele = searchspace_data_part[i][j*data_packing_factor + k];' + "\n")
        _host__file.append('                tmp.range(k*DATA_TYPE_TOTAL_SZ+ (DATA_TYPE_TOTAL_SZ - 1), ' + "\n")
        _host__file.append('                          k*DATA_TYPE_TOTAL_SZ) = this_ele.range(DATA_TYPE_TOTAL_SZ - 1, 0);' + "\n")
        _host__file.append('            }' + "\n")
        _host__file.append('            in[i][j] = tmp;' + "\n")
        _host__file.append('        }' + "\n")
        _host__file.append('    }' + "\n")

    _host__file.append('' + "\n")
    _host__file.append('    // run kernel' + "\n")
    _host__file.append('    auto start = high_resolution_clock::now();' + "\n")
    _host__file.append('    int64_t kernel_time_ns = tapa::invoke(Knn, FLAGS_bitstream,' + "\n")
    for PE_idx in range(_num_PE):
        _host__file.append('                 tapa::read_only_mmap<INTERFACE_WIDTH>(in[' + str(PE_idx) + ']),' + "\n")

    _host__file.append('                 tapa::write_only_mmap<INT32>(hw_output)' + "\n")
    _host__file.append('    );' + "\n")

    _host__file.append('' + "\n")
    _host__file.append('    auto stop = high_resolution_clock::now();' + "\n")
    _host__file.append('    duration<double> elapsed = stop - start;' + "\n")
    _host__file.append('    clog << "Total elapsed time: " << elapsed.count() << " s" << endl;' + "\n")
    _host__file.append('    clog << "KERNEL time: " << kernel_time_ns * 1e-9 << " s" << endl;' + "\n")
    _host__file.append('' + "\n")
    _host__file.append('    // Unpack the return values from the kernel' + "\n")
    _host__file.append('    for (int i = 0; i < 2*TOP; ++i)' + "\n")
    _host__file.append('    {' + "\n")
    _host__file.append('        //printf("KDEBUG HOST: i = %d, output = %f, ",' + "\n")
    _host__file.append('        //        i, hw_output[i].to_float());' + "\n")
    _host__file.append('        // Distance values' + "\n")
    _host__file.append('        if (i%2 == 1) {' + "\n")
    if (_knn_config.using_fixedpt and _knn_config.data_type_total_sz < 32):
        _host__file.append('            hw_dist_raw[i/2].range(DATA_TYPE_TOTAL_SZ-1, 0) = hw_output[i].range(DATA_TYPE_TOTAL_SZ-1, 0);' + "\n")
        _host__file.append('            printf("hw_dist_raw = %f\\n", hw_dist_raw[i/2].to_float());' + "\n")
    elif (_knn_config.using_fixedpt and _knn_config.data_type_total_sz == 32):
        _host__file.append('            hw_dist[i/2].range(DATA_TYPE_TOTAL_SZ-1, 0) = hw_output[i].range(DATA_TYPE_TOTAL_SZ-1, 0);' + "\n")
        _host__file.append('            printf("hw_dist = %f\\n", hw_dist[i/2].to_float());' + "\n")
    elif (_knn_config.using_float):
        _host__file.append('            hw_dist[i/2] = *(float*) &hw_output[i];' + "\n")
        _host__file.append('            printf("hw_dist = %f\\n", hw_dist[i/2]);' + "\n")

    _host__file.append('        }' + "\n")
    _host__file.append('        // ID values' + "\n")
    _host__file.append('        else {' + "\n")
    _host__file.append('            hw_id[i/2] = *((int*) (&hw_output[i]));' + "\n")
    _host__file.append('            printf("hw_id = %d\\n", hw_id[i/2]);' + "\n")
    _host__file.append('        }' + "\n")
    _host__file.append('    }' + "\n")

    _host__file.append('    // verify results' + "\n")
    _host__file.append('    bool match = true;' + "\n")
    
    if (_knn_config.data_type_total_sz < 32):
        _host__file.append('    match = verify(sw_dist, hw_dist_raw, hw_dist, sw_id, hw_id, query_data, searchspace_data, TOP);' + "\n")
    else:
        _host__file.append('    match = verify(sw_dist, hw_dist, sw_id, hw_id, query_data, searchspace_data, TOP);' + "\n")
    _host__file.append('    clog << (match ? "PASSED" : "FAILED") << endl;' + "\n")
    _host__file.append('    return (match ? EXIT_SUCCESS : EXIT_FAILURE);' + "\n")
    _host__file.append('}' + "\n")


    with open(host_file_name, 'w') as f:
        # go to start of file
        f.seek(0)
        # actually write the lines
        f.writelines(_host__file)



def Generate_Connectivity_Map(_memory_type, _num_PE, _port_width):
    connectivity_file_name = 'knn.ini'
    connectivity_file = []
    overall_pe_idx = 0

    connectivity_file.append('[connectivity]' + "\n")
    if (_memory_type == 'DDR4'):
        assert (max_port_width%_port_width == 0), f"ERROR: max port width {max_port_width} is not divisible by the port width {_port_width}"

        for PE_idx in range(_num_PE):
            bank_idx = int(PE_idx * _port_width/max_port_width)
            connectivity_file.append('sp=Knn.in_' + str(PE_idx) + ':DDR[' + str(bank_idx) + ']' + "\n")

        connectivity_file.append('sp=Knn.final_out:DDR[' + str(0) + ']' + "\n")

    elif (_memory_type == 'HBM2'):
        ### NOTE: TAPA/Autobridge generates a better mapping
        for PE_idx in range(_num_PE):
            connectivity_file.append('sp=Knn_1.in_' + str(PE_idx) + ':HBM[' + str(PE_idx) + ']' + "\n")

        connectivity_file.append('sp=Knn_1.final_out:HBM[' + str(_num_PE-1) + ']' + "\n")

    with open(connectivity_file_name, 'w') as f:
        # go to start of file
        f.seek(0)
        # actually write the lines
        f.writelines(connectivity_file)


def Generate_MakeFile(_kernel_freq, _fpga_part_name):
    make_file_name = 'Makefile'
    make_file = []
    clock_period = 1000/_kernel_freq

    make_file.append('.PHONY: help' + "\n")
    make_file.append('' + "\n")
    make_file.append('help::' + "\n")
    make_file.append('	$(ECHO) "Makefile Usage:"' + "\n")
    make_file.append('	$(ECHO) "  make all TARGET=<sw_emu/hw_emu/hw> DEVICE=<FPGA platform>"' + "\n")
    make_file.append('	$(ECHO) "      Command to generate the design for specified Target and Shell."' + "\n")
    make_file.append('	$(ECHO) ""' + "\n")
    make_file.append('	$(ECHO) "  make clean "' + "\n")
    make_file.append('	$(ECHO) "      Command to remove the generated non-hardware files."' + "\n")
    make_file.append('	$(ECHO) ""' + "\n")
    make_file.append('	$(ECHO) "  make cleanall"' + "\n")
    make_file.append('	$(ECHO) "      Command to remove all the generated files."' + "\n")
    make_file.append('	$(ECHO) ""' + "\n")
    make_file.append('	$(ECHO) "  make check TARGET=<sw_emu/hw_emu/hw> DEVICE=<FPGA platform>"' + "\n")
    make_file.append('	$(ECHO) "      Command to run application in emulation."' + "\n")
    make_file.append('	$(ECHO) ""' + "\n")
    make_file.append('	$(ECHO) "  make build TARGET=<sw_emu/hw_emu/hw> DEVICE=<FPGA platform>"' + "\n")
    make_file.append('	$(ECHO) "      Command to build xclbin application."' + "\n")
    make_file.append('	$(ECHO) ""' + "\n")
    make_file.append('' + "\n")
    make_file.append('DEVICE := xilinx_u280_xdma_201920_3' + "\n")
    make_file.append('# Points to top directory of Git repository' + "\n")
    make_file.append('COMMON_REPO = ./' + "\n")
    make_file.append('PWD = $(shell readlink -f .)' + "\n")
    make_file.append('ABS_COMMON_REPO = $(shell readlink -f $(COMMON_REPO))' + "\n")
    make_file.append('' + "\n")
    make_file.append('TARGET := hw' + "\n")
    make_file.append('HOST_ARCH := x86' + "\n")
    make_file.append('' + "\n")
    make_file.append('include ./utils.mk' + "\n")
    make_file.append('' + "\n")
    make_file.append('XSA := $(call device2xsa, $(DEVICE))' + "\n")
    make_file.append('TEMP_DIR := ./_x.$(TARGET).$(XSA)' + "\n")
    make_file.append('BUILD_DIR := ./build_dir.$(TARGET).$(XSA)' + "\n")
    make_file.append('' + "\n")
    make_file.append('VPP := v++' + "\n")
    make_file.append('' + "\n")
    make_file.append('#Include Libraries' + "\n")
    make_file.append('include $(ABS_COMMON_REPO)/common/includes/opencl/opencl.mk' + "\n")
    make_file.append('include $(ABS_COMMON_REPO)/common/includes/xcl2/xcl2.mk' + "\n")
    make_file.append('CXXFLAGS += $(xcl2_CXXFLAGS)' + "\n")
    make_file.append('LDFLAGS += $(xcl2_LDFLAGS)' + "\n")
    make_file.append('HOST_SRCS += $(xcl2_SRCS)' + "\n")
    make_file.append('CXXFLAGS += -pthread' + "\n")
    make_file.append('CXXFLAGS += $(opencl_CXXFLAGS) -Wall -O3 -g -std=c++17' + "\n")
    make_file.append('LDFLAGS += $(opencl_LDFLAGS)' + "\n")
    make_file.append('' + "\n")
    make_file.append('HOST_SRCS += src/knn-host.cpp ' + "\n")
    make_file.append('KNN_SRC = src/knn.cpp' + "\n")
    make_file.append('# Host compiler global settings' + "\n")
    make_file.append('CXXFLAGS += -fmessage-length=0' + "\n")
    make_file.append('CXXFLAGS += -I /opt/xilinx/xrt/lib -I /local-scratch/Xilinx/Vitis_HLS/2021.2/include' + "\n")
    make_file.append('LDFLAGS += -lrt -lstdc++ ' + "\n")
    make_file.append('LDFLAGS += -ltapa -lfrt -lglog -lgflags' + "\n")
    make_file.append('' + "\n")
    make_file.append('# Kernel compiler global settings' + "\n")
    make_file.append('CLFLAGS += -t $(TARGET) --platform $(DEVICE) --save-temps --kernel_frequency ' + str(_kernel_freq) + '' + "\n")
    make_file.append('ifneq ($(TARGET), hw)' + "\n")
    make_file.append('	CLFLAGS += -g' + "\n")
    make_file.append('endif' + "\n")
    make_file.append('' + "\n")
    make_file.append('' + "\n")
    make_file.append('ifeq ($(TARGET),$(filter $(TARGET),sw_emu))' + "\n")
    make_file.append('	CHECK_DEPENDENCY=$(EXECUTABLE) emconfig' + "\n")
    make_file.append('else' + "\n")
    make_file.append('	CHECK_DEPENDENCY=all' + "\n")
    make_file.append('endif' + "\n")
    make_file.append('' + "\n")
    make_file.append('CONFIGFILE = src/krnl_config.h' + "\n")
    make_file.append('INIFILE = src/knn.ini' + "\n")
    make_file.append('# Kernel linker flags' + "\n")
    make_file.append('LDCLFLAGS += --config src/knn.ini' + "\n")
    make_file.append('' + "\n")
    make_file.append('EXECUTABLE = knn' + "\n")
    make_file.append('CMD_ARGS = $(BUILD_DIR)/knn.xclbin' + "\n")
    make_file.append('EMCONFIG_DIR = $(TEMP_DIR)' + "\n")
    make_file.append('' + "\n")
    make_file.append('BINARY_CONTAINERS += $(BUILD_DIR)/knn.xclbin' + "\n")
    make_file.append('BINARY_CONTAINER_knn_OBJS += $(TEMP_DIR)/knn.xo' + "\n")
    make_file.append('CP = cp -rf' + "\n")
    make_file.append('' + "\n")
    make_file.append('.PHONY: all clean cleanall docs emconfig' + "\n")
    make_file.append('all: check-devices $(EXECUTABLE) $(BINARY_CONTAINERS) emconfig' + "\n")
    make_file.append('' + "\n")
    make_file.append('.PHONY: exe' + "\n")
    make_file.append('exe: $(EXECUTABLE)' + "\n")
    make_file.append('' + "\n")
    make_file.append('.PHONY: build' + "\n")
    make_file.append('build: $(BINARY_CONTAINERS)' + "\n")
    make_file.append('' + "\n")
    make_file.append('# Building kernel' + "\n")
    make_file.append('$(TEMP_DIR)/knn.xo: $(KNN_SRC)' + "\n")
    make_file.append('	mkdir -p $(TEMP_DIR)' + "\n")
    make_file.append('	mkdir -p build_script' + "\n")
    make_file.append('	tapac \\' + "\n")
    make_file.append('	      --work-dir $(TEMP_DIR) \\' + "\n")
    make_file.append('	      --top Knn \\' + "\n")
    make_file.append('	      --part-num ' + str(_fpga_part_name) + ' \\' + "\n")
    make_file.append('	      --clock-period ' + "{:.2f}".format(clock_period) + ' \\' + "\n")
    make_file.append('	      -o $(TEMP_DIR)/knn.xo \\' + "\n")
    make_file.append('	      --enable-synth-util \\' + "\n")

    ### ############ NOTE: Changing this just for the purposes of testing.
    ### for i in range(0, 10):
    ###     print("WARNING! WARNING! WARNING!")
    ###     print("USING MAX SEARCH TIME OF 30 SECONDS INSTEAD OF DEFAULT 10 MINUTES")
    ### make_file.append('	      --max-search-time 30 \\' + "\n")
    ### ############

    make_file.append('	      --max-parallel-synth-jobs 12 \\' + "\n")
    make_file.append('	      --run-tapacc \\' + "\n")
    make_file.append('	      --run-hls \\' + "\n")
    make_file.append('	      --generate-task-rtl \\' + "\n")
    make_file.append('	      --run-floorplanning \\' + "\n")
    make_file.append('	      --constraint build_script/knn_floorplan.tcl \\' + "\n")
    make_file.append('	      --generate-top-rtl \\' + "\n")
    make_file.append('	      --pack-xo \\' + "\n")
    if (memory_type == "HBM2"):
        make_file.append('	      --enable-hbm-binding-adjustment \\' + "\n")
    make_file.append('	      --connectivity $(INIFILE) \\' + "\n")
    make_file.append('	      --read-only-args in_.* \\' + "\n")
    make_file.append('	      --write-only-args final_out\\' + "\n")
    make_file.append('	      $(KNN_SRC)' + "\n")
    make_file.append('' + "\n")
    make_file.append('$(BUILD_DIR)/knn.xclbin: $(BINARY_CONTAINER_knn_OBJS)' + "\n")
    make_file.append('	mkdir -p $(BUILD_DIR)' + "\n")
    make_file.append('	$(VPP) $(CLFLAGS) --temp_dir $(BUILD_DIR) -l $(LDCLFLAGS) -o\'$@\' $(+)' + "\n")
    make_file.append('' + "\n")
    make_file.append('# Building Host' + "\n")
    make_file.append('$(EXECUTABLE): check-xrt $(HOST_SRCS) $(HOST_HDRS)' + "\n")
    make_file.append('	$(CXX) $(CXXFLAGS) $(HOST_SRCS) $(KNN_SRC) $(HOST_HDRS) -o \'$@\' $(LDFLAGS)' + "\n")
    make_file.append('' + "\n")
    make_file.append('emconfig:$(EMCONFIG_DIR)/emconfig.json' + "\n")
    make_file.append('$(EMCONFIG_DIR)/emconfig.json:' + "\n")
    make_file.append('	emconfigutil --platform $(DEVICE) --od $(EMCONFIG_DIR)' + "\n")
    make_file.append('' + "\n")
    make_file.append('check: $(CHECK_DEPENDENCY)' + "\n")
    make_file.append('	@echo $(CHECK_DEPENDENCY)' + "\n")
    make_file.append('ifeq ($(TARGET),$(filter $(TARGET),sw_emu))' + "\n")
    make_file.append('	$(CP) $(EMCONFIG_DIR)/emconfig.json .' + "\n")
    make_file.append('	XCL_EMULATION_MODE=$(TARGET) ./$(EXECUTABLE)' + "\n")
    make_file.append('else ifeq ($(TARGET),$(filter $(TARGET),hw_emu))' + "\n")
    make_file.append('	$(CP) $(EMCONFIG_DIR)/emconfig.json .' + "\n")
    make_file.append('	XCL_EMULATION_MODE=$(TARGET) ./$(EXECUTABLE) --bitstream=$(BUILD_DIR)/knn.xclbin' + "\n")
    make_file.append('else' + "\n")
    make_file.append('	./$(EXECUTABLE) $(BUILD_DIR)/knn.xclbin' + "\n")
    make_file.append('endif' + "\n")
    make_file.append('' + "\n")
    make_file.append('tapa_HLS: $(TEMP_DIR)/knn.xo' + "\n")
    make_file.append('' + "\n")
    make_file.append('# Cleaning stuff' + "\n")
    make_file.append('clean:' + "\n")
    make_file.append('	-$(RMDIR) $(EXECUTABLE) ' + "\n")
    make_file.append('	-$(RMDIR) profile_* TempConfig system_estimate.xtxt *.rpt *.csv ' + "\n")
    make_file.append('	-$(RMDIR) src/*.ll *v++* .Xil emconfig.json dltmp* xmltmp* *.log *.jou *.wcfg *.wdb' + "\n")
    make_file.append('' + "\n")
    make_file.append('cleanall: clean' + "\n")
    make_file.append('	-$(RMDIR) build_dir* sd_card*' + "\n")
    make_file.append('	-$(RMDIR) _x.* *xclbin.run_summary qemu-memory-_* emulation/ _vimage/ pl* start_simulation.sh *.xclbin' + "\n")

    with open(make_file_name, 'w') as f:
        # go to start of file
        f.seek(0)
        # actually write the lines
        f.writelines(make_file)



def Generate_hw_build_script(_knn_config, _kernel_freq):
    hw_gen_file_name = 'generate_bitstream.sh'
    hw_gen_file = []

    hw_gen_file.append('# run cosim or generate bitstream' + "\n")
    hw_gen_file.append('TARGET=hw' + "\n")
    hw_gen_file.append('# TARGET=hw_emu     ## (NOTE: As of May 2, this is untested)' + "\n")
    hw_gen_file.append('# DEBUG=-g' + "\n")
    hw_gen_file.append('' + "\n")
    hw_gen_file.append('KERNEL_NAME="Knn"' + "\n")
    hw_gen_file.append('TOP="knn"' + "\n")
    hw_gen_file.append('XO="$(pwd)/${TOP}.xo"' + "\n")
    hw_gen_file.append('CONSTRAINT="$(pwd)/${TOP}_floorplan.tcl"' + "\n")

    hw_gen_file.append('#CONFIG_FILE="../src/knn.ini"' + "\n")
    hw_gen_file.append('CONFIG_FILE="$(pwd)/run/link_config.ini"  ### This only works if we are using the U280, because the INI file is generated by autobridge for the auto-HBM setup.' + "\n")

    hw_gen_file.append('TARGET_FREQUENCY=' + str(_kernel_freq) + "\n")
    hw_gen_file.append('MAX_SYNTH_JOBS=16' + "\n")
    hw_gen_file.append('' + "\n")
    hw_gen_file.append('## in our experience, the EarlyBlockPlacement strategy works better' + "\n")
    hw_gen_file.append('## for designs with lots of DSPs and BRAMs' + "\n")
    hw_gen_file.append('#STRATEGY="Explore"' + "\n")
    hw_gen_file.append('#PLACEMENT_STRATEGY="EarlyBlockPlacement"' + "\n")
    hw_gen_file.append('' + "\n")

    hw_gen_file.append('PLATFORM={}'.format(FPGA_target_name) + "\n")

    hw_gen_file.append('' + "\n")
    hw_gen_file.append('# where to save the intermediate results' + "\n")
    hw_gen_file.append('OUTPUT_DIR="$(pwd)/vitis_run_${TARGET}"' + "\n")
    hw_gen_file.append('' + "\n")
    hw_gen_file.append('# check that the floorplan tcl exists' + "\n")
    hw_gen_file.append('if [ ! -f "$CONSTRAINT" ]; then' + "\n")
    hw_gen_file.append('    echo "no constraint file found"' + "\n")
    hw_gen_file.append('    exit' + "\n")
    hw_gen_file.append('fi' + "\n")
    hw_gen_file.append('' + "\n")
    hw_gen_file.append('v++ ${DEBUG}\\' + "\n")
    hw_gen_file.append('  --link \\' + "\n")
    hw_gen_file.append('  --output "${OUTPUT_DIR}/${TOP}_${PLATFORM}.xclbin" \\' + "\n")
    hw_gen_file.append('  --kernel ${KERNEL_NAME} \\' + "\n")
    hw_gen_file.append('  --platform ${PLATFORM} \\' + "\n")
    hw_gen_file.append('  --target ${TARGET} \\' + "\n")
    hw_gen_file.append('  --report_level 2 \\' + "\n")
    hw_gen_file.append('  --temp_dir "${OUTPUT_DIR}/${TOP}_${PLATFORM}.temp" \\' + "\n")
    hw_gen_file.append('  --optimize 3 \\' + "\n")
    hw_gen_file.append('  --connectivity.nk ${KERNEL_NAME}:1:${KERNEL_NAME} \\' + "\n")
    hw_gen_file.append('  --save-temps \\' + "\n")
    hw_gen_file.append('  ${XO} \\' + "\n")
    hw_gen_file.append('  --config ${CONFIG_FILE} \\' + "\n")
    hw_gen_file.append('  --kernel_frequency ${TARGET_FREQUENCY} \\' "\n")
    hw_gen_file.append('  --vivado.prop run.impl_1.STEPS.PHYS_OPT_DESIGN.is_enabled=1 \\' + "\n")
    hw_gen_file.append('  --vivado.prop run.impl_1.STEPS.OPT_DESIGN.ARGS.DIRECTIVE=Explore \\' + "\n")
    if (_knn_config.input_dim >= 8 and _knn_config.using_float):
        hw_gen_file.append('  --vivado.prop run.impl_1.STEPS.PLACE_DESIGN.ARGS.DIRECTIVE=EarlyBlockPlacement \\' + "\n")
    else:
        hw_gen_file.append('  --vivado.prop run.impl_1.STEPS.PLACE_DESIGN.ARGS.DIRECTIVE=Explore \\' + "\n")
    hw_gen_file.append('  --vivado.prop run.impl_1.STEPS.PHYS_OPT_DESIGN.ARGS.DIRECTIVE=Explore \\' + "\n")
    hw_gen_file.append('  --vivado.prop run.impl_1.STEPS.ROUTE_DESIGN.ARGS.DIRECTIVE=Explore \\' + "\n")
    hw_gen_file.append('  --vivado.prop run.impl_1.STEPS.OPT_DESIGN.TCL.PRE=$CONSTRAINT' + "\n")

    with open(hw_gen_file_name, 'w') as f:
        # go to start of file
        f.seek(0)
        # actually write the lines
        f.writelines(hw_gen_file)

    ## set RWX permissions for the user
    os.chmod(hw_gen_file_name, stat.S_IRUSR|stat.S_IWUSR|stat.S_IXUSR)



def Generate_tapa_script(_kernel_freq, _fpga_part_name):
    _tapac_file_name = "generate_xo.sh"
    _tapac_file = []
    clock_period = 1000/_kernel_freq

    _tapac_file.append('tapac \\' + "\n")
    _tapac_file.append('      --work-dir run \\' + "\n")
    _tapac_file.append('      --top Knn \\' + "\n")
    _tapac_file.append('      --part-num ' + str(_fpga_part_name) + ' \\' + "\n")
    _tapac_file.append('      --clock-period ' + "{:.2f}".format(clock_period) + ' \\' + "\n")
    _tapac_file.append('      -o knn.xo \\' + "\n")
    _tapac_file.append('      --enable-synth-util \\' + "\n")
    _tapac_file.append('      --max-parallel-synth-jobs 12 \\' + "\n")
    _tapac_file.append('      --run-tapacc \\' + "\n")
    _tapac_file.append('      --run-hls \\' + "\n")
    _tapac_file.append('      --generate-task-rtl \\' + "\n")
    _tapac_file.append('      --run-floorplanning \\' + "\n")
    _tapac_file.append('      --constraint knn_floorplan.tcl \\' + "\n")
    _tapac_file.append('      --generate-top-rtl \\' + "\n")
    _tapac_file.append('      --pack-xo \\' + "\n")
    if (memory_type == "HBM2"):
        _tapac_file.append('      --enable-hbm-binding-adjustment \\' + "\n")
    _tapac_file.append('      --connectivity ../src/knn.ini \\' + "\n")
    _tapac_file.append('      --read-only-args in_.* \\' + "\n")
    _tapac_file.append('      --write-only-args final_out\\' + "\n")
    _tapac_file.append('      ../src/knn.cpp' + "\n")

    with open(_tapac_file_name, 'w') as f:
        # go to start of file
        f.seek(0)
        # actually write the lines
        f.writelines(_tapac_file)

    ## set RWX permissions for the user
    os.chmod(_tapac_file_name, stat.S_IRUSR|stat.S_IWUSR|stat.S_IXUSR)



def Generate_data_collection_python_script(_knn_config):
    ## This file is meant to be generated in the gen_design/build/ directory.
    _data_coll_file_name = "CHIPKNN_estimate_runtime.py"
    _data_coll_file = []

    _data_coll_file.append('import sys' + '\n')
    _data_coll_file.append('import os' + '\n')
    _data_coll_file.append('import re' + '\n')
    _data_coll_file.append('' + '\n')
    _data_coll_file.append('#######################################' + '\n')
    _data_coll_file.append('## RUNTIME ESTIMATION:' + '\n')
    _data_coll_file.append('#######################################' + '\n')
    _data_coll_file.append('' + '\n')
    _data_coll_file.append('def Get_HLS_Max_Latency(_fname):' + '\n')
    _data_coll_file.append('    latencies_line_num = 32         ## The HLS latencies show up on this line # of the report.' + '\n')
    _data_coll_file.append('' + '\n')
    _data_coll_file.append('    the_file = open(_fname, "r")' + '\n')
    _data_coll_file.append('    latency_str = the_file.readlines()[latencies_line_num - 1]' + '\n')
    _data_coll_file.append('    latency_str = latency_str.split("|")[2].strip()' + '\n')
    _data_coll_file.append('' + '\n')
    _data_coll_file.append('    return int(latency_str)' + '\n')
    _data_coll_file.append('' + '\n')
    _data_coll_file.append('' + '\n')
    _data_coll_file.append('"""' + '\n')
    _data_coll_file.append('### This function parses the HLS-reported latencies from the multi-PE design, and estimates the runtime of the design.' + '\n')
    _data_coll_file.append('"""' + '\n')
    _data_coll_file.append('def Estimate_Runtime_from_HLS_Latencies(_achieved_memsys_freq, _achieved_kern_freq, _approx_num_hiermerge_stages):' + '\n')
    _data_coll_file.append('' + '\n')
    _data_coll_file.append('    report_dir_relpath = "run/report/"' + '\n')
    _data_coll_file.append('' + '\n')
    _data_coll_file.append('    load_rpt_fname = "load_KNN_csynth.rpt"' + '\n')
    _data_coll_file.append('    compute_rpt_fname = "compute_KNN_csynth.rpt"' + '\n')
    _data_coll_file.append('    sort_rpt_fname = "para_partial_sort_csynth.rpt"' + '\n')
    _data_coll_file.append('    merge_rpt_fname = "merge_dual_streams_csynth.rpt"' + '\n')
    _data_coll_file.append('    load_HLS_cycles = 0' + '\n')
    _data_coll_file.append('    compute_HLS_cycles = 0' + '\n')
    _data_coll_file.append('    sort_HLS_cycles = 0' + '\n')
    _data_coll_file.append('    merge_HLS_cycles = 0' + '\n')
    _data_coll_file.append('' + '\n')
    _data_coll_file.append('    #########################' + '\n')
    _data_coll_file.append('    ## Grab the HLS latencies' + '\n')
    _data_coll_file.append('' + '\n')
    _data_coll_file.append('    load_HLS_cycles     = Get_HLS_Max_Latency(report_dir_relpath + load_rpt_fname)' + '\n')
    _data_coll_file.append('    compute_HLS_cycles  = Get_HLS_Max_Latency(report_dir_relpath + compute_rpt_fname)' + '\n')
    _data_coll_file.append('    sort_HLS_cycles     = Get_HLS_Max_Latency(report_dir_relpath + sort_rpt_fname)' + '\n')
    _data_coll_file.append('    merge_HLS_cycles    = Get_HLS_Max_Latency(report_dir_relpath + merge_rpt_fname)' + '\n')

    _data_coll_file.append('' + '\n')
    _data_coll_file.append('    #########################' + '\n')
    _data_coll_file.append('    ## Estimate the runtime' + '\n')
    _data_coll_file.append('' + '\n')
    _data_coll_file.append('' + '\n')
    _data_coll_file.append('    max_kern_freq = 225' + '\n')
    _data_coll_file.append('    max_memsys_freq = 450' + '\n')
    _data_coll_file.append('    MEMSYS_SCALAR = 0.93' + '\n')
    _data_coll_file.append('' + '\n')
    _data_coll_file.append('    ### Modify the cycle estimates, to correct for frequency.' + '\n')
    _data_coll_file.append('    ### For load, divide by a correction factor to account for frequency disparities,' + '\n')
    _data_coll_file.append('    ### and the theoretical vs practical peak bandwidth.' + '\n')
    _data_coll_file.append('    load_cycles_CORRECTED       = load_HLS_cycles / (MEMSYS_SCALAR * min(_achieved_memsys_freq/max_memsys_freq, _achieved_kern_freq/max_kern_freq))' + '\n')
    _data_coll_file.append('    compute_cycles_CORRECTED    = compute_HLS_cycles / (_achieved_kern_freq/max_kern_freq)' + '\n')
    _data_coll_file.append('    sort_cycles_CORRECTED       = sort_HLS_cycles / (_achieved_kern_freq/max_kern_freq)' + '\n')

    _data_coll_file.append('    merge_cycles_CORRECTED      = merge_HLS_cycles / (_achieved_kern_freq/max_kern_freq)' + '\n')
    _data_coll_file.append('' + '\n')

    _data_coll_file.append('    total_cycles = max(load_cycles_CORRECTED, compute_cycles_CORRECTED, sort_cycles_CORRECTED) + _approx_num_hiermerge_stages * merge_cycles_CORRECTED' + '\n')

    _data_coll_file.append('' + '\n')
    _data_coll_file.append('    estimated_runtime = float(total_cycles) / (max_kern_freq*1000*1000)' + '\n')
    _data_coll_file.append('' + '\n')
    _data_coll_file.append('    return estimated_runtime' + '\n')
    _data_coll_file.append('' + '\n')
    _data_coll_file.append('' + '\n')
    _data_coll_file.append('def Log_Runtime_Estimate(_out_file_name, _achieved_memsys_freq, _achieved_kern_freq, _num_hiermerge_stages={}):'.format(_knn_config.approx_num_hiermerge_stages) + '\n')
    _data_coll_file.append('    out_file_contents = []' + '\n')
    _data_coll_file.append('' + '\n')
    _data_coll_file.append('    out_file_contents.append("  RUNTIME ESTIMATION\\n")' + '\n')
    _data_coll_file.append('    out_file_contents.append("------------------------------------------------------------\\n")' + '\n')
    _data_coll_file.append('    out_file_contents.append("Runtime estimation script is using:\\n")' + '\n')
    _data_coll_file.append('    out_file_contents.append("  achieved_memsys_freq = {}\\n". format(_achieved_memsys_freq))' + '\n')
    _data_coll_file.append('    out_file_contents.append("  achieved_kern_freq = {}\\n".   format(_achieved_kern_freq))' + '\n')
    _data_coll_file.append('    out_file_contents.append("  num_hiermerge_stages = {}\\n". format(_num_hiermerge_stages))' + '\n')
    _data_coll_file.append('' + '\n')
    _data_coll_file.append('    estimated_runtime = Estimate_Runtime_from_HLS_Latencies(_achieved_memsys_freq, _achieved_kern_freq, _num_hiermerge_stages)' + '\n')
    _data_coll_file.append('    out_file_contents.append("Estimated runtime is: {}\\n ".format(estimated_runtime))' + '\n')
    _data_coll_file.append('    out_file_contents.append("\\n\\n\\n")' + '\n')
    _data_coll_file.append('' + '\n')
    _data_coll_file.append('    with open(_out_file_name, "w") as f:' + '\n')
    _data_coll_file.append('        # go to start of file' + '\n')
    _data_coll_file.append('        f.seek(0)' + '\n')
    _data_coll_file.append('        # actually write the lines' + '\n')
    _data_coll_file.append('        f.writelines(out_file_contents)' + '\n')
    _data_coll_file.append('' + '\n')
    _data_coll_file.append('#######################################' + '\n')
    _data_coll_file.append('## DATA GRABBING:' + '\n')
    _data_coll_file.append('#######################################' + '\n')
    _data_coll_file.append('' + '\n')
    _data_coll_file.append('' + '\n')
    _data_coll_file.append('def _Get_HW_Resource_Total_CLB_LUT(util_report_lines):' + '\n')
    _data_coll_file.append('    for line in util_report_lines:' + '\n')
    _data_coll_file.append('        if ("CLB LUTs" in line):' + '\n')
    _data_coll_file.append('            total_resources = line.split("|")[5]' + '\n')
    _data_coll_file.append('            total_resources = total_resources.strip()' + '\n')
    _data_coll_file.append('            break' + '\n')
    _data_coll_file.append('' + '\n')
    _data_coll_file.append('    return float(total_resources)' + '\n')
    _data_coll_file.append('' + '\n')
    _data_coll_file.append('' + '\n')
    _data_coll_file.append('def _Get_HW_Resource_Total_CLB_REG(util_report_lines):' + '\n')
    _data_coll_file.append('    for line in util_report_lines:' + '\n')
    _data_coll_file.append('        if ("CLB Registers" in line):' + '\n')
    _data_coll_file.append('            reg_resources = line.split("|")[5]' + '\n')
    _data_coll_file.append('            reg_resources = reg_resources.strip()' + '\n')
    _data_coll_file.append('            break' + '\n')
    _data_coll_file.append('' + '\n')
    _data_coll_file.append('    return float(reg_resources)' + '\n')
    _data_coll_file.append('' + '\n')
    _data_coll_file.append('' + '\n')
    _data_coll_file.append('def _Get_HW_Resource_Total_FF(util_report_lines):' + '\n')
    _data_coll_file.append('    for line in util_report_lines:' + '\n')
    _data_coll_file.append('        if ("Register as Flip Flop" in line):' + '\n')
    _data_coll_file.append('            ff_resources = line.split("|")[5]' + '\n')
    _data_coll_file.append('            ff_resources = ff_resources.strip()' + '\n')
    _data_coll_file.append('            break' + '\n')
    _data_coll_file.append('' + '\n')
    _data_coll_file.append('    return float(ff_resources)' + '\n')
    _data_coll_file.append('' + '\n')
    _data_coll_file.append('' + '\n')
    _data_coll_file.append('def _Get_HW_Resource_Total_CLB(util_report_lines):' + '\n')
    _data_coll_file.append('    section = 0' + '\n')
    _data_coll_file.append('    for line in util_report_lines:' + '\n')
    _data_coll_file.append('        if ("2. CLB Logic Distribution" in line):' + '\n')
    _data_coll_file.append('            section += 1' + '\n')
    _data_coll_file.append('        elif ("CLB      " in line) and (section == 2):' + '\n')
    _data_coll_file.append('            total_resources = line.split("|")[5]' + '\n')
    _data_coll_file.append('            total_resources = total_resources.strip()' + '\n')
    _data_coll_file.append('            break' + '\n')
    _data_coll_file.append('' + '\n')
    _data_coll_file.append('    return float(total_resources)' + '\n')
    _data_coll_file.append('' + '\n')
    _data_coll_file.append('' + '\n')
    _data_coll_file.append('def _Get_HW_Resource_Total_BRAM(util_report_lines):' + '\n')
    _data_coll_file.append('    section = 0' + '\n')
    _data_coll_file.append('    for line in util_report_lines:' + '\n')
    _data_coll_file.append('        if ("3. BLOCKRAM" in line):' + '\n')
    _data_coll_file.append('            section += 1' + '\n')
    _data_coll_file.append('        elif ("Block RAM Tile" in line) and (section == 2):' + '\n')
    _data_coll_file.append('            total_resources = line.split("|")[5]' + '\n')
    _data_coll_file.append('            total_resources = total_resources.strip()' + '\n')
    _data_coll_file.append('            break' + '\n')
    _data_coll_file.append('' + '\n')
    _data_coll_file.append('    return float(total_resources)' + '\n')
    _data_coll_file.append('' + '\n')
    _data_coll_file.append('def _Get_HW_Resource_Total_URAM(util_report_lines):' + '\n')
    _data_coll_file.append('    section = 0' + '\n')
    _data_coll_file.append('    for line in util_report_lines:' + '\n')
    _data_coll_file.append('        if ("3. BLOCKRAM" in line):' + '\n')
    _data_coll_file.append('            section += 1' + '\n')
    _data_coll_file.append('        elif ("URAM" in line) and (section == 2):' + '\n')
    _data_coll_file.append('            total_resources = line.split("|")[5]' + '\n')
    _data_coll_file.append('            total_resources = total_resources.strip()' + '\n')
    _data_coll_file.append('            break' + '\n')
    _data_coll_file.append('' + '\n')
    _data_coll_file.append('    return float(total_resources)' + '\n')
    _data_coll_file.append('' + '\n')
    _data_coll_file.append('' + '\n')
    _data_coll_file.append('def _Get_HW_Resource_Total_DSP(util_report_lines):' + '\n')
    _data_coll_file.append('    section = 0' + '\n')
    _data_coll_file.append('    for line in util_report_lines:' + '\n')
    _data_coll_file.append('        if ("4. ARITHMETIC" in line):' + '\n')
    _data_coll_file.append('            section += 1' + '\n')
    _data_coll_file.append('        elif ("DSPs" in line) and (section == 2):' + '\n')
    _data_coll_file.append('            total_resources = line.split("|")[5]' + '\n')
    _data_coll_file.append('            total_resources = total_resources.strip()' + '\n')
    _data_coll_file.append('            break' + '\n')
    _data_coll_file.append('' + '\n')
    _data_coll_file.append('    return float(total_resources)' + '\n')
    _data_coll_file.append('' + '\n')
    _data_coll_file.append('' + '\n')
    _data_coll_file.append('def _Get_HW_Resource_CLB_per_SLR(util_report_lines):' + '\n')
    _data_coll_file.append('    clb_per_slr = [0, 0, 0]' + '\n')
    _data_coll_file.append('    section = 0' + '\n')
    _data_coll_file.append('    for line in util_report_lines:' + '\n')
    _data_coll_file.append('        if ("14. SLR CLB Logic and Dedicated Block Utilization" in line):' + '\n')
    _data_coll_file.append('            section += 1' + '\n')
    _data_coll_file.append('        elif ("CLB    " in line) and (section == 2):' + '\n')
    _data_coll_file.append('            for i in range(0, 3):' + '\n')
    _data_coll_file.append('                clb_per_slr[i] = line.split("|")[5+i]' + '\n')
    _data_coll_file.append('                clb_per_slr[i] = clb_per_slr[i].strip()' + '\n')
    _data_coll_file.append('                clb_per_slr[i] = float(clb_per_slr[i])' + '\n')
    _data_coll_file.append('            break' + '\n')
    _data_coll_file.append('' + '\n')
    _data_coll_file.append('    return clb_per_slr' + '\n')
    _data_coll_file.append('' + '\n')
    _data_coll_file.append('' + '\n')
    _data_coll_file.append('' + '\n')
    _data_coll_file.append('def Log_HW_Resource_Usages(_out_file_name):' + '\n')
    _data_coll_file.append('    out_file_contents = []' + '\n')
    _data_coll_file.append('    out_file_contents.append("  UTILIZATION REPORTS" + "\\n")' + '\n')
    _data_coll_file.append('    out_file_contents.append("------------------------------------------------------------" + "\\n")' + '\n')
    _data_coll_file.append('' + '\n')
    _data_coll_file.append('    report_dir_relpath = "vitis_run_hw/knn_{}.temp/reports/link/imp/"'.format(FPGA_target_name) + '\n')
    _data_coll_file.append('    util_report_fname = "impl_1_full_util_routed.rpt"' + '\n')
    _data_coll_file.append('' + '\n')
    _data_coll_file.append('    util_report_file = open(report_dir_relpath + util_report_fname, "r")' + '\n')
    _data_coll_file.append('    util_report_lines = util_report_file.readlines()' + '\n')
    _data_coll_file.append('' + '\n')
    _data_coll_file.append('    total_LUT_usage     = _Get_HW_Resource_Total_CLB_LUT    (util_report_lines)' + '\n')
    _data_coll_file.append('    total_CLB_usage     = _Get_HW_Resource_Total_CLB        (util_report_lines)' + '\n')
    _data_coll_file.append('    total_CLB_REG_usage = _Get_HW_Resource_Total_CLB_REG    (util_report_lines)' + '\n')
    _data_coll_file.append('    total_FF_usage      = _Get_HW_Resource_Total_FF         (util_report_lines)' + '\n')
    _data_coll_file.append('    total_BRAM_usage    = _Get_HW_Resource_Total_BRAM       (util_report_lines)' + '\n')
    _data_coll_file.append('    total_URAM_usage    = _Get_HW_Resource_Total_URAM       (util_report_lines)' + '\n')
    _data_coll_file.append('    total_DSP_usage     = _Get_HW_Resource_Total_DSP        (util_report_lines)' + '\n')
    _data_coll_file.append('    CLBs_per_SLR_usage  = _Get_HW_Resource_CLB_per_SLR      (util_report_lines)' + '\n')
    _data_coll_file.append('' + '\n')
    _data_coll_file.append('    for i in range(0, 3):' + '\n')
    _data_coll_file.append('        out_file_contents.append("CLBs in SLR {}: {}".format(i, CLBs_per_SLR_usage[i]) + "\\n")' + '\n')
    _data_coll_file.append('    out_file_contents.append("Total LUT Usage:      {}".format(total_LUT_usage) + "\\n")' + '\n')
    _data_coll_file.append('    out_file_contents.append("Total CLB_REG Usage:  {}".format(total_CLB_REG_usage) + "\\n")' + '\n')
    _data_coll_file.append('    out_file_contents.append(" NOTE: Total FF Usage:      {}".format(total_FF_usage) + "\\n")' + '\n')
    _data_coll_file.append('    out_file_contents.append("Total BRAM Usage:     {}".format(total_BRAM_usage) + "\\n")' + '\n')
    _data_coll_file.append('    out_file_contents.append("Total URAM Usage:     {}".format(total_URAM_usage) + "\\n")' + '\n')
    _data_coll_file.append('    out_file_contents.append("Total DSP Usage:      {}".format(total_DSP_usage) + "\\n")' + '\n')
    _data_coll_file.append('' + '\n')
    _data_coll_file.append('    out_file_contents.append("Total CLB Usage:  {}".format(total_CLB_usage) + "\\n")' + '\n')
    _data_coll_file.append('' + '\n')
    _data_coll_file.append('    with open(_out_file_name, "a") as f:' + '\n')
    _data_coll_file.append('        f.writelines(out_file_contents)' + '\n')
    _data_coll_file.append('' + '\n')
    _data_coll_file.append('' + '\n')
    _data_coll_file.append('def Get_frequencies():' + '\n')
    _data_coll_file.append('    report_dir_relpath = "vitis_run_hw/"' + '\n')
    _data_coll_file.append('    freq_report_fname = "knn_{}.xclbin.info"'.format(FPGA_target_name) + '\n')
    _data_coll_file.append('' + '\n')
    _data_coll_file.append('    freq_report_file = open(report_dir_relpath + freq_report_fname, "r")' + '\n')
    _data_coll_file.append('    freq_report_lines = freq_report_file.readlines()' + '\n')
    _data_coll_file.append('' + '\n')
    _data_coll_file.append('    section = 0' + '\n')
    _data_coll_file.append('    for line in freq_report_lines:' + '\n')
    _data_coll_file.append('        if ("DATA_CLK" in line):' + '\n')
    _data_coll_file.append('            section = 1' + '\n')
    _data_coll_file.append('        elif ("hbm_aclk" in line):' + '\n')
    _data_coll_file.append('            section = 2' + '\n')
    _data_coll_file.append('        elif ("KERNEL_CLK" in line):' + '\n')
    _data_coll_file.append('            break' + '\n')
    _data_coll_file.append('        elif ("Frequency" in line) and (section == 1):' + '\n')
    _data_coll_file.append('            kern_freq = line.split(":")[1]' + '\n')
    _data_coll_file.append('            kern_freq = kern_freq.split("MHz")[0].strip()' + '\n')
    _data_coll_file.append('            kern_freq = int(kern_freq)' + '\n')
    _data_coll_file.append('        elif ("Frequency" in line) and (section == 2):' + '\n')
    _data_coll_file.append('            mem_freq = line.split(":")[1]' + '\n')
    _data_coll_file.append('            mem_freq = mem_freq.split("MHz")[0].strip()' + '\n')
    _data_coll_file.append('            mem_freq = int(mem_freq)' + '\n')
    _data_coll_file.append('' + '\n')
    _data_coll_file.append('    return (mem_freq, kern_freq)' + '\n')
    _data_coll_file.append('' + '\n')
    _data_coll_file.append('' + '\n')
    _data_coll_file.append('if __name__ == "__main__":' + '\n')
    _data_coll_file.append('    if ((len(sys.argv) > 1)):' + '\n')
    _data_coll_file.append('        print("")' + '\n')
    _data_coll_file.append('        print("ERROR: Incorrect arguments.")' + '\n')
    _data_coll_file.append('        print("     This program does not take any CLI arguments.")' + '\n')
    _data_coll_file.append('        print("")' + '\n')
    _data_coll_file.append('        sys.exit(-1)' + '\n')
    _data_coll_file.append('' + '\n')
    _data_coll_file.append('    output_filename = "RUNTIME_AND_RESOURCES.log"' + '\n')
    _data_coll_file.append('' + '\n')
    _data_coll_file.append('    (mem_freq, kern_freq) = Get_frequencies()' + '\n')
    _data_coll_file.append('    Log_Runtime_Estimate(output_filename, mem_freq, kern_freq)' + '\n')
    _data_coll_file.append('' + '\n')
    _data_coll_file.append('    Log_HW_Resource_Usages(output_filename)' + '\n')


    with open(_data_coll_file_name, 'w') as f:
        # go to start of file
        f.seek(0)
        # actually write the lines
        f.writelines(_data_coll_file)

    ## set RWX permissions for the user
    os.chmod(_data_coll_file_name, stat.S_IRUSR|stat.S_IWUSR|stat.S_IXUSR)

